### JAVASCRIPT ###

Utilité = interaction utilisateur, manipulation du DOM, aspect algo (créer des boucles etc)
Inconvénients = pas de communication avec le serveur, pas de gestion de fichiers (création, écriture, etc). D'où l'invention de Node.js 

DOM = Document Object Model, modèle objet d'une page HTML 
Objet window est le plus grand 
> Objets document, location, navigation, history, etc
=> https://www.w3schools.com/jsref/obj_window.asp 
> html 
> etc 

ATTENTION compatibilité des navigateurs = tous les browsers sont obligt compatibles avec ECMAScript 2009, les plus gros browsers supportent ECMAScript 2022. Attention à la syntaxe utilisée

NB querySelector prend en compte les sélecteurs css, donc on peut utiliser not first child par ex. 

; en js => recommandé mais non obligatoire jusqu'à fin années 2010. PB => erreurs 
Depuis ECMAScript 6, au choix du dév qui maîtrise le sujet.
ATTENTION : TOUJOURS METTRE UN ; DERRIERE UN CONSOLE.LOG, sinon erreurs dramatiques (pb d'exécution du code)

NB RACCOURCIS VSC
alt + flèche bas ou rester cliquer sur mollette souris et descendre => pour écrire du texte dans plusieurs balises 
ctrl + F2 pour sélectionner toutes les occurrences
Navigation entre les occurrences => ctrl + d vers la prochaine, ctrl + u vers la précédente

Pour accéder à la classe d'un élément
classList = tableau de toutes les classes d'un élément 
className = string de toutes les classes

ATTENTION
TOUTE METHODE OU FONCTION QUI COMMENCE OU CONTIENT UN VERBE CONJUGUE RETOURNE UN BOOLEEN 
Ex : contains() 
Check matches() => https://developer.mozilla.org/fr/docs/Web/API/Element/matches 

ATTENTION 
toggle est plus coûteux car contient un if else, utiliser plutôt un replace 

NB si on n'indique pas à js qu'on est en mode strict au début du fichier, on n'est pas obligés de définir les variables pour les déclarer ex : var images = [...] => images = [...] 

Parcours du DOM => il vaut mieux récupérer les éléments du DOM à l'intérieur des fonctions => éléments parcourus que lorsque c'est nécessaire, cela évite de parcourir le DOM inutilement à chaque chargement du fichier 

SEPARATION OF CONCERNS => normalement, on ne met pas plusieurs langages dans un même fichier (ex html dans js, etc). C'est parfois nécessaire pour certains langages ex : PHP, mais c'est "moche"  


var, let, const => attention aux vieux browsers

ATTENTION 
function (a, b) {
    return a + b
}
console.log(somme(2));
=> va renvoyer NaN parce que JS lit somme(2, undefined)

IDEAL = valeurs par défaut pour les paramètres
function (a=0, b=0) {
    return a + b
}


ARROW FUNCTIONS 
var somme = (a = 0, b = 0) => a + b
Ecriture en une ligne, avantages = return est implicite, gain de place, intéressant pour les fonctions simples, implémenté dans pleins de langages. Si la fonction fait plus de choses, ajouter les accolades + retour à la ligne + return.
Inconvénients = pas d'accès au this

FONCTIONS PURES 
Une fonction qui ne fait qu'une seule chose.
Ex : splice() fait ajout, suppression et extraction. C'est donc une fonction impure. Aujourd'hui on privilégie les fonctions pures, surtout dans les fonctions prédéfinies du langage. 


EVENEMENTS 
event.preventDefault()
Pour annuler un évènement, passer un event en paramètre de la fonction callback de addEventListener() et utiliser preventDefault(). ATTENTION ne fonctionne pas avec tous les évènements => click ne peut pas être annulé.
Ne sert pas qu'à empêcher la soumission d'un formulaire...

removeEventListener() dissocie l'évènement de la fonction callback 
Ex : 
var addComment = () => {
    // code ...
    btn.removeEventListener('click', addComment)
}
btn.addEventListener('click', addComment)

=> Au premier clic, l'évént sera exécuté, puis il sera supprimé.